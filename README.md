# Hamming Numbers difficulty 4 kyu kata SOLVED
* [Description](README.md#description-of-issue)
* [First solution (didn't work on large nums)](README.md#firstly-i-tried-to-do-a-heap-solution-didnt-solve)
* [First code complexity](README.md#key-operations-and-their-complexities)
    * [Time Complexity](README.md#overall-time-complexity)
    * [Space complexity](README.md#space-complexity)
* [Solution](README.md#actual-solution)
    * [Time complexity](README.md#time-complexity)
    * [Space complexity](README.md#space-complexity-1)

Description of issue
=
A [Hamming number](https://en.wikipedia.org/wiki/Regular_number) is a positive integer of the form *2i3j5k*, for some non-negative integers *i*, *j*, and *k*.

Write a function that computes the *nth* smallest Hamming number.

Specifically:

* The first smallest Hamming number is 1 = $2^03^05^0$
* The second smallest Hamming number is 2 = $2^13^05^0$
* The third smallest Hamming number is 3 = $2^03^15^0$
* The fourth smallest Hamming number is 4 = $2^23^05^0$
* The fifth smallest Hamming number is 5 = $2^03^05^1$

The 20 smallest Hamming numbers are given in the 
Example test fixture.

Your code should be able to compute the first `5 000` ( LC: `400`, Clojure: `2 000`, Haskell: `12 691`, NASM, C, D, C++, Go and Rust: `13 282` ) Hamming numbers **without timing out**.

Firstly I tried to do a [heap solution](main.c). Didn't solve.
=
## Data Structures and Functions
1. **MinHeap Structure:**

* The `MinHeap` structure is used to represent the min-heap, which acts as a priority queue. It contains:

    * **`data:`** A dynamic array of long long integers.
    * **`size:`** The current number of elements in the heap.
    * **`capacity:`** The maximum number of elements the heap can hold before needing to be resized.
2. **createMinHeap(int capacity):**

* This function initializes a new `MinHeap` with a specified capacity. It allocates memory for the heap structure and its data array.
3. *swap(long long x, long long y)**:*

* A utility function that swaps the values of two elements in the heap.
4. _*heapifyDown(MinHeap minHeap, int idx)**:_

* This function ensures that the heap property is maintained when an element is removed from the heap. It compares the element at index idx with its children and swaps it with the smaller child if necessary, then recursively calls itself to fix the heap.
5. _*heapifyUp(MinHeap minHeap, int idx)**:_

* This function ensures that the heap property is maintained when a new element is inserted into the heap. It compares the element at index idx with its parent and swaps them if the child is smaller, then recursively calls itself to fix the heap upwards.
6. _*extractMin(MinHeap minHeap)**:_

* This function removes and returns the smallest element (the root) from the heap. It replaces the root with the last element in the heap, decreases the heap size, and calls heapifyDown to restore the heap property.
7. _*insertMinHeap(MinHeap minHeap, long long val)**:_

* This function inserts a new value into the heap. If the heap is full, it doubles its capacity. The new value is added to the end of the heap, and heapifyUp is called to restore the heap property.
8. **nthRegularNumber(int n):**

* This function calculates the nth regular number using the min-heap. It starts by inserting the smallest regular number (1) into the heap.
* For each regular number from 1 to n, the smallest number is extracted from the heap. To avoid duplicates, any subsequent numbers that are the same as the just-extracted number are also removed.
* The function then inserts the next potential regular numbers (obtained by multiplying the current regular number by 2, 3, and 5) into the heap.
* The nth regular number is returned.

## Key Operations and Their Complexities
1. **Inserting into the Min-Heap (`insertMinHeap`):**

    * Inserting an element into a min-heap has a time complexity of 𝑂(log 𝑘), where 𝑘 is the current size of the heap.
    * The heap size is at most 𝑂(𝑛) since, in the worst case, each regular number and its multiples might be in the heap at some point.
2. **Extracting the Minimum Element (`extractMin`):**

    * Extracting the minimum element from a min-heap also has a time complexity of 𝑂(log 𝑘).
3. **Removing Duplicates:**

    * The code checks for duplicates by extracting elements from the heap until the current minimum element is different from the previously extracted element. In the worst case, this might involve multiple extract operations, but each such operation is still 𝑂(log 𝑘).
4. **Generating Regular Numbers:**

    * For each regular number extracted from the heap, three new regular numbers are generated by multiplying the current regular number by **2**, **3**, and **5**, and these are then inserted into the heap.
    * Therefore, for each of the n iterations, there are up to 3 insert operations, each taking 𝑂(log 𝑘).
### Overall Time Complexity
* The primary loop runs 𝑛 times, and in each iteration, the code performs a constant number of heap operations (inserts and extracts), each of which has a time complexity of 𝑂(log 𝑘).
* Since the heap size 𝑘 can grow to at most 𝑂(𝑛), each heap operation takes 𝑂(log 𝑛).

Thus, the overall time complexity of the `nthRegularNumber` function is:

<center>𝑂(𝑛log 𝑛)</center>

### Space Complexity
* The space complexity is dominated by the size of the heap, which can grow up to 𝑂(𝑛) elements.
* The space complexity is therefore 𝑂(𝑛).

<center>𝑂(𝑛)</center>

[Actual solution](hamming.c)
=
## Key Components and Functions
1. **Array Initialization:**

* `bases[] = {2, 3, 5}`: This array stores the prime factors used to generate the Hamming numbers.
* `expos[] = {0, 0, 0}`: This array keeps track of the indices in the Hamming number sequence that are used to generate the next multiple of 2, 3, or 5.
* `hamms`: This dynamically allocated array stores the first n Hamming numbers.
2. Generating Hamming Numbers:

* The first Hamming number is initialized as 1: `hamms[0] = 1.`
* The loop runs from `j = 1` to `n - 1` to generate the next Hamming numbers.
* In each iteration:
    * `next_hamms[]`: An array that stores the next potential Hamming number by multiplying the current Hamming number at the respective index by 2, 3, and 5.
    * `next_hamm`: This variable holds the minimum value from `next_hamms[]`, which will be the next Hamming number.
    * The generated Hamming number is stored in `hamms[j]`.
    * The `expos[]` array is updated to ensure the next Hamming number is generated correctly by moving the index forward for the base that was used to generate `next_hamm`.
3. Final Output:

* After the loop completes, the nth Hamming number is stored in `hamms[n - 1]`.
* The dynamically allocated memory is freed before returning the result.
### Time Complexity
* **Inner Loop (Generating Next Hamming Number)**: Each iteration requires finding the minimum of three potential next Hamming numbers, which is 𝑂(1).
* **Overall Time Complexity**: Since the outer loop runs `n` times, the time complexity is 𝑂(𝑛).
### Space Complexity
* **Array hamms[]:** This array stores `n` Hamming numbers, leading to a space complexity of 𝑂(𝑛).
* **Additional Space:** The arrays `bases[]`, `expos[]`, and `next_hamms[]` are all of constant size, contributing 𝑂(1) additional space.

## Summary
### Time Complexity: 
## <center>𝑂(𝑛)</center>
### Space Complexity:
## <center>𝑂(𝑛)</center>